#!perl

# DATE
# VERSION

use 5.010;
use strict;
use warnings;

use Perinci::CmdLine::Any;

our %SPEC;

$SPEC{validate_with_sah} = {
    v => 1.1,
    summary => 'Validate data with Sah schema',
    description => <<'_',

This script is useful for testing Sah schemas. You can quickly specify from the
CLI a schema with some data to validate it against. This script can also be used
to just normalize a Sah schema and show it (`--show-schema`), or compile a
schema and show the raw compilation result (`--show-raw-compile`), or generate
validator code and show it (`--show-code`).

_
    args_rels => {
        'choose_one&' => [
            [qw/show_schema show_raw_compile show_code/],
        ],
        'req_one&' => [
            [qw/schema schema_file/],
            [qw/data multiple_data data_file multiple_data_file/],
        ],
        'dep_any&' => [
            ['linenum', [qw/show_code/]],
            ['schema_file_type', [qw/schema_file/]],
            ['data_file_type', [qw/data_file multiple_data_file/]],
        ],
    },
    args => {
        schema => {
            schema=>'any*',
            pos=>0,
            tags => ['category:schema-specification'],
        },
        schema_file => {
            schema=>'str*',
            summary => 'Retrieve schema from file',
            description => <<'_',

JSON and YAML formats are supported. File type will be guessed from filename,
defaults to JSON.

_
            cmdline_aliases => {f=>{}},
            'x.schema.entity' => 'filename',
            tags => ['category:schema-specification'],
        },
        schema_file_type => {
            schema=>['str*', in=>[qw/json yaml/]],
            summary => 'Give hint for schema file type',
            cmdline_aliases => {t=>{}},
            tags => ['category:schema-specification'],
        },

        data => {
            schema => ['any'],
            pos => 1,
            tags => ['category:data-specification'],
        },
        multiple_data => {
            summary => 'Validate multiple data (array of data) against schema',
            schema => ['array*', of=>'any'],
            tags => ['category:data-specification'],
        },
        data_file => {
            schema=>'str*',
            summary => 'Retrieve data from file',
            description => <<'_',

JSON and YAML formats are supported. File type will be guessed from filename,
defaults to JSON.

_
            'x.schema.entity' => 'filename',
            tags => ['category:data-specification'],
        },
        multiple_data_file => {
            schema=>'str*',
            summary => 'Retrieve multiple data from file',
            description => <<'_',

This is like `data_file` except that for multiple data. Data must be an array.

_
            'x.schema.entity' => 'filename',
            tags => ['category:data-specification'],
        },
        data_file_type => {
            schema=>['str*', in=>[qw/json yaml/]],
            summary => 'Give hint for data file type',
            tags => ['category:data-specification'],
        },

        return_type => {
            schema=>['str*', in=>[qw/bool str full/]],
            default=>'str',
            cmdline_aliases => {r=>{}},
            tags => ['category:validator-specification'],
        },
        show_schema => {
            summary => "Don't validate data, show normalized schema only",
            schema=>['bool', is=>1],
            cmdline_aliases => {s=>{}},
            tags => ['category:action-selection'],
        },
        show_raw_compile => {
            summary => "Don't validate data, show raw compilation result only",
            schema=>['bool', is=>1],
            tags => ['category:action-selection'],
        },
        show_code => {
            summary => "Don't validate data, show generated validator code only",
            schema=>['bool', is=>1],
            cmdline_aliases => {c=>{}},
            tags => ['category:action-selection'],
        },
        data_with_result => {
            summary => "Show data alongside with validation result",
            description => <<'_',

The default is to show the validation result only.

_
            schema=>['bool', is=>1],
            cmdline_aliases => {d=>{}},
            tags => ['category:output'],
        },
        with_debug => {
            summary => 'Generate validator with debug on',
            description => <<'_',

This means e.g. to pepper the validator code with logging statements.

_
            schema => ['bool', is=>1],
            tags => ['category:validator-specification'],
        },
        pp => {
            summary => 'Generate Perl validator that avoids the use of XS module',
            schema => ['bool', is=>1],
            tags => ['category:validator-specification'],
            # XXX only relevant when compiler=perl
        },
        compiler => {
            summary => "Select compiler",
            schema=>['str*', in=>[qw/perl js/]],
            default => 'perl',
            cmdline_aliases => {C=>{}},
            tags => ['category:validator-specification'],
        },
        linenum => {
            summary => 'When showing source code, add line numbers',
            schema=>['bool', is=>1],
            cmdline_aliases => {l=>{}},
            tags => ['category:output'],
        },
    },
    examples => [
        {
            src => q([[prog]] 'int*' 42),
            src_plang => 'bash',
            summary => 'Should succeed and return empty string',
        },
        {
            src => q([[prog]] 'int*' '"x"'),
            src_plang => 'bash',
            summary => 'Should show an error message because "x" is not int',
        },
        {
            src => q([[prog]] '["int","min",1,"max",10]' --multiple-data-json '[-4,7,15]' --return-type bool),
            src_plang => 'bash',
            summary => 'Validate multiple data, should return 0, 1, 0',
        },
        {
            src => q([[prog]] '["int","min",1,"max",10]' --multiple-data-json '[-4,7,15]' -d),
            src_plang => 'bash',
            summary => 'Show data alongside with result, in a table',
        },
        {
            src => q([[prog]] '["int","min",1,"max",10]' -c -l),
            src_plang => 'bash',
            summary => 'Show validator Perl code only, with line number',
        },
        {
            src => q([[prog]] '["int","min",1,"max",10]' -C js -c -l),
            src_plang => 'bash',
            summary => 'Show validator JS code only, with line number',
        },
        {
            src => q{[[prog]] -f schema1.json '["data"]'},
            src_plang => 'bash',
            summary => 'Load schema from file',
        },
        {
            src => q{[[prog]] -f schema1.json --multiple-data-file datafile --data-file-type json},
            src_plang => 'bash',
            summary => 'Load schema and data from file',
        },
    ],
};
sub validate_with_sah {
    my %args = @_;

    my $schema;
    if (defined $args{schema}) {
        return [400, "Please specify either 'schema' or 'schema_file', not both"] if defined($args{schema_file});
        $schema = $args{schema};
    } elsif (defined $args{schema_file}) {
        my $path = $args{schema_file};
        my $type = $args{schema_file_type};
        if (!$type) {
            if ($path =~ /\b(json)$/i) { $type = 'json' }
            elsif ($path =~ /\b(yaml|yml)$/i) { $type = 'yaml' }
            else { $type = 'json' }
        }
        if ($type eq 'json') {
            require File::Slurper;
            require JSON;
            my $ct = File::Slurper::read_text($path);
            $schema = JSON->new->allow_nonref->decode($ct);
        } elsif ($type eq 'yaml') {
            require YAML::XS;
            $schema = YAML::XS::LoadFile($path);
        } else {
            return [400, "Unknown schema file type '$type', please specify json/yaml"];
        }
    } else {
        return [400, "Please specify 'schema' or 'schema_file'"];
    }

    if ($args{show_schema}) {
        require Data::Sah::Normalize;
        return [200, "OK", Data::Sah::Normalize::normalize_schema($schema)];
    }

    my $func;
    my $obj;
    {
        no strict 'refs';
        my $c = $args{compiler};
        if ($c eq 'perl') {
            require Data::Sah;
            if ($args{show_raw_compile}) {
                $obj = Data::Sah->new->get_compiler('perl');
            } else {
                $func = \&{"Data::Sah::gen_validator"};
            }
        } elsif ($c eq 'js') {
            if ($args{show_raw_compile}) {
                $obj = Data::Sah->new->get_compiler('perl');
            } else {
                require Data::Sah::JS;
                $func = \&{"Data::Sah::JS::gen_validator"};
            }
        } else {
            return [400, "Unknown compiler '$c', please specify perl/js"];
        }
    }

    my %gen_opts;
    {
        $gen_opts{source} = 1 if $args{show_code};
        $gen_opts{return_type} = $args{return_type};
        $gen_opts{debug} = 1 if $args{with_debug};
        $gen_opts{pp} = 1 if $args{pp};
    }

    if ($args{show_raw_compile}) {
        require Data::Dump;
        my $cd = $obj->compile(%gen_opts, schema=>$schema);
        return [200, "OK", Data::Dump::dump($cd), {'cmdline.skip_format'=>1}];
    }

    my $v = $func->($schema, \%gen_opts);

    if ($args{show_code}) {
        $v .= "\n" unless $v =~ /\R\z/;
        if ($args{linenum}) {
            require String::LineNumber;
            $v = String::LineNumber::linenum($v);
        }
        return [200, "OK", $v, {'cmdline.skip_format'=>1}];
    }

    my $data;
    my $multiple;
    if (exists $args{data}) {
        $data = $args{data};
    } elsif ($args{multiple_data}) {
        $data = $args{multiple_data};
        $multiple = 1;
    } elsif (defined($args{data_file}) || defined($args{multiple_data_file})) {
        my $path;
        if (defined $args{data_file}) {
            $path = $args{data_file};
        } else {
            $path = $args{multiple_data_file};
            $multiple = 1;
        }
        my $type = $args{data_file_type};
        if (!$type) {
            if ($path =~ /\b(json)$/i) { $type = 'json' }
            elsif ($path =~ /\b(yaml|yml)$/i) { $type = 'yaml' }
            else { $type = 'json' }
        }
        if ($type eq 'json') {
            require File::Slurper;
            require JSON;
            my $ct = File::Slurper::read_text($path);
            $data = JSON->new->allow_nonref->decode($ct);
        } elsif ($type eq 'yaml') {
            require YAML::XS;
            $data = YAML::XS::LoadFile($path);
        } else {
            return [400, "Unknown data file type '$type', please specify json/yaml"];
        }
    } else {
        return [400, "Please specify 'data' or 'multiple_data' or 'data_file' or 'multiple_data_file'"];
    }
    if ($multiple) {
        return [400, "Multiple data must be an array"] unless ref($data) eq 'ARRAY';
    }

    if ($multiple) {
        if ($args{data_with_result}) {
            return [200, "OK", [map {{data=>$_, result=>$v->($_)}} @$data]];
        } else {
            return [200, "OK", [map {$v->($_)} @$data]];
        }
    } else {
        if ($args{data_with_result}) {
            return [200, "OK", {data=>$data, result=>$v->($data)}];
        } else {
            return [200, "OK", $v->($data)];
        }
    }

    [500, "BUG: This should not be reached"];
}

my $cli = Perinci::CmdLine::Any->new(
    url => '/main/validate_with_sah',
);
$cli->{common_opts}{naked_res}{default} = 1;
$cli->run;

# ABSTRACT:
# PODNAME:
